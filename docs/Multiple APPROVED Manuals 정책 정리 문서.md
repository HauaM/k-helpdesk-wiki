# Multiple APPROVED Manuals 정책 정리 문서

## 1. 작업 배경

현재 시스템은 `(업무코드, 에러코드)` 조합을 기준으로 메뉴얼을 그룹화하고 있으며, LLM 기반 상담 분석 결과를 바탕으로 신규 메뉴얼 초안을 생성하고 승인(APPROVED) 상태로 전환하는 구조를 가지고 있다.

기존 설계에서는 동일한 `(업무코드, 에러코드)` 그룹 내에서 **항상 하나의 APPROVED 메뉴얼만 존재**한다는 전제를 두고 있었다. 이로 인해 새로운 메뉴얼이 승인될 경우, 기존 APPROVED 메뉴얼을 전부 `DEPRECATED` 처리하는 방식이 사용되었다.

하지만 실제 운영 환경에서는 동일한 업무코드와 에러코드를 가지더라도 **원인·상황·조치 방법이 서로 다른 여러 갈래의 메뉴얼이 공존**하는 경우가 빈번하다. 이 구조에서 기존 정책을 유지할 경우 다음과 같은 문제가 발생했다.

* 서로 다른 갈래의 지식이 신규 승인 과정에서 함께 `DEPRECATED` 되어 지식 누락 발생
* 벡터 검색 및 비교 로직에서 적절한 비교 대상 선택 실패
* `/draft` API 호출 시 `NEW / SIMILAR / SUPPLEMENT` 판정의 신뢰도 저하

이에 따라, 동일 그룹 내 **다중 APPROVED 메뉴얼을 허용**하면서도, 버전 관리와 검색 효율을 동시에 유지하기 위한 정책 정리가 필요해졌다.

---

## 2. 핵심 compare() 정책

본 프로젝트에서는 다음 두 가지 정책을 **비가역적 기준 정책**으로 확정하여 적용한다.

### 2.1 APPROVED 후보 전체 기반 best_match 선정

* `ComparisonService.compare()`는 특정 메뉴얼 하나만을 비교 대상으로 삼지 않는다.
* 동일 `(업무코드, 에러코드)`를 가지며 `status = APPROVED` 인 **모든 메뉴얼을 비교 후보**로 조회한다.
* 후보 전체를 대상으로 우선순위 평가를 수행한 뒤, **가장 적합한 단일 메뉴얼(best_match)** 을 먼저 선정한다.

이 정책의 목적은 다음과 같다.

* 비교 대상 선택 오류로 인한 `NEW` 오판정 방지
* 실제로 가장 유사한 기존 지식과의 비교 보장
* 다중 APPROVED 구조에서도 비교 결과의 일관성 유지

### 2.2 SIMILAR / SUPPLEMENT 시 단일 메뉴얼만 DEPRECATED

best_match가 선정된 이후 최종 판정은 아래 규칙을 따른다.

* 판정 결과가 `SIMILAR` 또는 `SUPPLEMENT` 인 경우

  * **best_match로 선정된 기존 메뉴얼 1건만 `DEPRECATED` 처리**
  * 신규 메뉴얼은 `APPROVED` 상태로 등록

* 판정 결과가 `NEW` 인 경우

  * 기존 메뉴얼은 유지
  * 신규 메뉴얼을 추가 APPROVED 메뉴얼로 등록

이를 통해 다음을 보장한다.

* 서로 다른 갈래의 지식이 의도치 않게 함께 폐기되는 문제 방지
* 명확한 “대체 관계”를 가지는 메뉴얼만 버전 업
* 동일 그룹 내에서 다중 APPROVED 메뉴얼의 안정적 공존

---

## 3. sub_category 미사용 결정 배경

sub_category는 `(업무코드, 에러코드)` 그룹 내부를 다시 세분화하는 명시적 분류 키로서, 검색 및 비교 효율을 높일 수 있는 장점이 있다.

그러나 본 프로젝트에서는 다음 이유로 **sub_category 컬럼을 도입하지 않기로 결정**하였다.

* 자동 분류 로직 및 검증 로직 추가로 인한 처리 흐름 복잡도 증가
* 분류 오류 발생 시 오히려 비교 결과 왜곡 가능성
* 운영 단계에서 분류 정책 변경 시 영향 범위 확대
* 실시간 처리 성능에 대한 보수적 고려

대신, 이미 시스템에 도입되어 있는 **LLM 기반 키워드 추출 기능**을 활용하여 sub_category에 준하는 역할을 수행하도록 설계 방향을 조정하였다.

---

## 4. sub_category 대신 keyword 활용 전략

### 4.1 키워드의 역할 정의

LLM은 메뉴얼 생성 시 **1~3개의 핵심 키워드**를 추출한다. 이 키워드는 다음과 같은 성격을 가진다.

* 메뉴얼의 원인 또는 상황을 요약하는 의미 단위
* 사람이 이해 가능한 자연어 라벨
* 고정된 분류값이 아닌 유연한 분기 신호

본 설계에서는 이 키워드를 **"Soft sub_category"** 로 정의한다.

---

### 4.2 compare() 단계에서의 키워드 사용 방식

키워드는 최종 판정을 직접 결정하지 않으며, **후보 압축(candidate reduction)** 용도로 사용한다.

#### 비교 흐름 요약

1. 1차 후보 수집

   * `(업무코드, 에러코드)` + `status = APPROVED`

2. 2차 후보 압축 (선택적)

   * 신규 초안 키워드와 기존 메뉴얼 키워드의 **교집합 개수** 계산
   * 교집합이 존재하는 메뉴얼을 우선 후보로 선정
   * 교집합이 전혀 없을 경우 전체 후보를 그대로 유지 (fallback)

3. best_match 선정

   * 압축된 후보 집합을 대상으로 벡터 유사도 비교
   * 가장 높은 유사도의 메뉴얼 1건을 best_match로 확정

4. 최종 판정

   * best_match 기준으로 `SIMILAR / SUPPLEMENT / NEW` 판정 수행

이 방식은 다음 장점을 가진다.

* 키워드 품질이 높을수록 비교 정확도 향상
* 키워드 품질이 낮아도 fallback으로 안전한 동작 보장
* sub_category 없이도 갈래 분리 효과 확보

---

### 4.3 검색(Search) 단계에서의 키워드 활용

검색 시에도 키워드는 다음과 같이 활용될 수 있다.

* `(업무코드, 에러코드)` 필터 이후
* 키워드 교집합 수 또는 포함 여부를 가중치로 사용하여 정렬 보정
* 최종 결과는 벡터 유사도 + 키워드 가중치의 혼합 점수로 노출

이를 통해 동일 그룹 내에서 서로 다른 갈래의 메뉴얼이 섞여 노출되는 현상을 완화한다.

---

## 5. 기대 효과 정리

본 정책 적용을 통해 다음을 기대할 수 있다.

* 동일 업무/에러코드 내 다중 APPROVED 메뉴얼의 안정적 운영
* 불필요한 `NEW` 메뉴얼 폭증 방지
* 지식 누락 없는 버전 관리
* sub_category 도입 없이도 준수한 검색 및 비교 품질 확보
* 처리 성능 저하 없이 확장 가능한 구조 유지

---

## 6. 결론

본 설계는 다음 원칙 위에 구축된다.

* **비교는 넓게, 폐기는 좁게**
* **자동 분류는 최소화하고, 비교 정확도는 구조로 확보**
* **지식은 삭제가 아닌 선택적 대체로 관리**

이를 통해 시스템은 실사용 환경에서 발생하는 다양한 상담 시나리오를 안정적으로 수용할 수 있으며, 장기적인 메뉴얼 품질과 검색 효율을 동시에 유지할 수 있다.
